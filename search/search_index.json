{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#home","title":"Home","text":"Quote <p>\u201cTalk is cheap. Show me the code.\u201d</p> <ul> <li>Linus Torvalds</li> </ul>"},{"location":"#dsa-data-structures-and-algorithms","title":"\ud83e\udde0 DSA (Data Structures and Algorithms):","text":"<ul> <li>Definition: A core computer science subject that involves learning how data is stored and manipulated efficiently (Data Structures) and the logic for solving problems step-by-step (Algorithms).</li> <li>Examples: Arrays, Linked Lists, Trees, Graphs, Sorting Algorithms, Searching Algorithms, etc.</li> <li>Purpose: To build problem-solving skills and understand how to write efficient code.</li> </ul>"},{"location":"#leetcode","title":"\ud83d\udcbb LeetCode:","text":"<ul> <li>Definition: A popular online platform that provides coding problems for practice, mainly focused on DSA topics.</li> <li>Purpose: To practice and apply DSA concepts by solving real-world interview-style questions.</li> <li>Features: Practice problems, contests, mock interviews, and company-specific questions.</li> </ul>"},{"location":"#summary","title":"\u2705 Summary:","text":"Topic DSA LeetCode What it is A subject in computer science A platform for DSA problem practice Purpose Learn concepts Practice and master those concepts Relationship Foundation Application <p>So, DSA is what you learn, and LeetCode is where you practice it.</p>"},{"location":"#books","title":"Books","text":""},{"location":"#reference","title":"Reference","text":"<ul> <li>Codeless Data Structures and Algorithms by Armstrong Subero</li> <li>Tech Icons</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap-what-to-learn-after-dsa-leetcode-basics","title":"\ud83d\ude80 Roadmap: What to Learn After DSA &amp; LeetCode Basics","text":"<p>This roadmap covers the most important computer science topics and algorithms to learn beyond just solving LeetCode problems and understanding data structures.</p>"},{"location":"roadmap/#1-algorithmic-paradigms","title":"1. Algorithmic Paradigms","text":"<p>These help you solve problems efficiently, not just brute-force them.</p> Paradigm Description Examples Notes Recursion A function calls itself. Factorial, DFS View Notes Backtracking Explore all possibilities. N-Queens, Sudoku Solver Divide and Conquer Break problems into sub-problems. Merge Sort, Quick Sort Greedy Algorithms Make locally optimal choices. Activity Selection, Huffman Dynamic Programming Optimize overlapping sub-problems. Knapsack, Fibonacci, LIS"},{"location":"roadmap/#2-mathematics-for-programming","title":"2. Mathematics for Programming","text":"<p>Important for solving tricky problems.</p> Topic Use Case GCD, LCM Number theory problems Prime Numbers Sieve of Eratosthenes, Primality Modulo Arithmetic Combinatorics, Hashing Combinations/Permutations Counting problems Probability Some hard-level LeetCode questions"},{"location":"roadmap/#3-string-algorithms","title":"3. String Algorithms","text":"<p>Not just basic string problems \u2014 go deeper.</p> Topic Description KMP Algorithm Pattern searching Z-Algorithm Fast substring search Rabin-Karp Rolling hash Trie Data Structure Prefix-based search (autocomplete)"},{"location":"roadmap/#4-graph-algorithms","title":"4. Graph Algorithms","text":"<p>Huge part of tech interviews and real-world systems.</p> Algorithm Use Case DFS, BFS Traversal, connectivity Dijkstra's Shortest path (weighted graph) Bellman-Ford Negative weight paths Floyd-Warshall All-pairs shortest paths Union-Find Disjoint set problems Topological Sort Task scheduling"},{"location":"roadmap/#progress-tracker","title":"\u2705 Progress Tracker","text":""},{"location":"roadmap/#algorithmic-paradigms","title":"\ud83d\udd39 Algorithmic Paradigms","text":"<ul> <li> Recursion</li> <li> Backtracking</li> <li> Divide and Conquer</li> <li> Greedy Algorithms</li> <li> Dynamic Programming</li> </ul>"},{"location":"roadmap/#graph-algorithms","title":"\ud83d\udd39 Graph Algorithms","text":"<ul> <li> DFS / BFS</li> <li> Dijkstra\u2019s</li> <li> Union-Find</li> <li> Topological Sort</li> </ul>"},{"location":"roadmap/#string-algorithms","title":"\ud83d\udd39 String Algorithms","text":"<ul> <li> KMP Algorithm</li> <li> Trie</li> </ul>"},{"location":"blog/","title":"Index","text":""},{"location":"blog/#blog","title":"Blog","text":""},{"location":"dsa/arrays/","title":"Arrays","text":""},{"location":"dsa/arrays/#arrays","title":"Arrays","text":"<p>Arrays are linear data structures that store elements of the same type in contiguous memory locations.</p>"},{"location":"dsa/arrays/#operations","title":"Operations","text":"<ul> <li>Access</li> <li>Insertion</li> <li>Deletion</li> <li>Traversal</li> </ul>"},{"location":"dsa/big_o/","title":"Big O Notation","text":""},{"location":"dsa/big_o/#big-o-notation","title":"Big O Notation","text":"<p>Big O notation describes the time and space complexity of algorithms. It helps us understand how algorithms scale with input size.</p>"},{"location":"dsa/big_o/#common-complexities","title":"Common Complexities","text":"Complexity Name Example Use Case O(1) Constant Time Accessing an array element O(log n) Logarithmic Time Binary Search O(n) Linear Time Traversing an array O(n log n) Linearithmic Time Merge Sort, Quick Sort (avg case) O(n\u00b2) Quadratic Time Bubble Sort, nested loops O(2\u207f) Exponential Time Recursive Fibonacci O(n!) Factorial Time Brute-force permutations"},{"location":"dsa/big_o/#why-it-matters","title":"Why It Matters","text":"<p>Big O helps you:</p> <ul> <li>Write efficient algorithms.</li> <li>Choose the right data structure.</li> <li>Optimize LeetCode solutions to pass all test cases.</li> </ul>"},{"location":"dsa/big_o/#related-to","title":"Related To","text":"<ul> <li>DSA: Analyze the cost of operations like insert, delete, search.</li> <li>LeetCode: Improve performance of your code under tight time constraints.</li> </ul>"},{"location":"dsa/data_structures/","title":"Types of Data Structures","text":""},{"location":"dsa/data_structures/#types-of-data-structures","title":"Types of Data Structures","text":"<p>Data structures are ways of organizing and storing data efficiently. They are broadly classified into several categories:</p>"},{"location":"dsa/data_structures/#1-linear-data-structures","title":"\ud83d\udd39 1. Linear Data Structures","text":"<p>Data is stored sequentially.</p> Structure Description Example Array Fixed-size collection of same-type elements. <code>[1, 2, 3, 4]</code> Linked List Elements connected using pointers. Singly/Doubly List Stack Last-In-First-Out (LIFO) structure. Browser history Queue First-In-First-Out (FIFO) structure. Task scheduler"},{"location":"dsa/data_structures/#2-non-linear-data-structures","title":"\ud83d\udd39 2. Non-Linear Data Structures","text":"<p>Data is stored in a hierarchical or graph-based form.</p> Structure Description Example Tree Hierarchical data structure with nodes. Binary Tree, BST Graph Network of connected nodes. Social network, maps"},{"location":"dsa/data_structures/#3-hash-based-data-structures","title":"\ud83d\udd39 3. Hash-Based Data Structures","text":"<p>Use hashing to organize and retrieve data efficiently.</p> Structure Description Hash Map Key-value pair, fast average access. Hash Set Stores unique values using hashing."},{"location":"dsa/data_structures/#4-advanced-specialized-structures","title":"\ud83d\udd39 4. Advanced / Specialized Structures","text":"Structure Use Case / Purpose Heap / Priority Queue Quick access to highest/lowest element. Trie Efficient for string/prefix searching. Segment Tree Efficient range queries and updates. Disjoint Set Track connected components in graphs."},{"location":"dsa/data_structures/#real-world-analogies","title":"\ud83d\udca1 Real-World Analogies","text":"Data Structure Analogy Array Row of mailboxes Stack Stack of plates Queue Queue at a bank or store Tree Family tree Graph Subway map or web of friends"},{"location":"dsa/linked_lists/","title":"Linked Lists","text":""},{"location":"dsa/linked_lists/#linked-lists","title":"Linked Lists","text":"<p>A linked list is a linear data structure where each element (node) points to the next.</p>"},{"location":"dsa/linked_lists/#types","title":"Types","text":"<ul> <li>Singly Linked List</li> <li>Doubly Linked List</li> <li>Circular Linked List</li> </ul>"},{"location":"dsa/trees/","title":"Trees","text":""},{"location":"dsa/trees/#trees","title":"Trees","text":"<p>Trees are hierarchical data structures consisting of nodes.</p>"},{"location":"dsa/trees/#types","title":"Types","text":"<ul> <li>Binary Tree</li> <li>Binary Search Tree</li> <li>AVL Tree</li> <li>Heap</li> </ul>"},{"location":"leetcode/array_problems/","title":"Array Problems","text":""},{"location":"leetcode/array_problems/#leetcode-array-problems","title":"LeetCode Array Problems","text":"<p>Here are some solved array problems from LeetCode.</p> <ul> <li>Two Sum</li> <li>Best Time to Buy and Sell Stock</li> <li>Maximum Subarray</li> </ul>"},{"location":"leetcode/dynamic_programming/","title":"Dynamic Programming","text":""},{"location":"leetcode/dynamic_programming/#leetcode-dynamic-programming-problems","title":"LeetCode Dynamic Programming Problems","text":"<ul> <li>Climbing Stairs</li> <li>Longest Increasing Subsequence</li> <li>House Robber</li> </ul>"},{"location":"leetcode/linked_list_problems/","title":"Linked List Problems","text":""},{"location":"leetcode/linked_list_problems/#leetcode-linked-list-problems","title":"LeetCode Linked List Problems","text":"<ul> <li>Reverse Linked List</li> <li>Merge Two Sorted Lists</li> <li>Detect Cycle in a Linked List</li> </ul>"},{"location":"topics/recursion/","title":"Recursion","text":""},{"location":"topics/recursion/#recursion","title":"\ud83d\udd01 Recursion","text":""},{"location":"topics/recursion/#key-concepts","title":"\u2705 Key Concepts","text":"<ul> <li>A function that calls itself with a base case.</li> <li>Often used in tree traversal, backtracking, and divide-and-conquer.</li> </ul>"},{"location":"topics/recursion/#common-patterns","title":"\ud83d\udccc Common Patterns","text":"<ul> <li>Base case + recursive step</li> <li>Stack overflow risk</li> <li>Call stack tracing</li> </ul>"},{"location":"topics/recursion/#examples","title":"\ud83d\udca1 Examples","text":"<ul> <li>Factorial</li> <li>Fibonacci</li> <li>Power of a number</li> </ul>"},{"location":"topics/recursion/#must-solve-leetcode-problems","title":"\ud83e\udde0 Must-Solve LeetCode Problems","text":"<ul> <li> Factorial (Recursive)</li> <li> Climbing Stairs</li> <li> Permutations</li> </ul>"}]}